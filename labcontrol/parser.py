import json
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Union
from urllib.parse import unquote

from labcontrol.browser.utils import clear_content, parse_accumulated_time
from labcontrol.schema import (
    AWSDetailsRunning,
    AWSDetailsStopped,
    SeleniumCookie,
    VocareumParams,
)


def cookies_to_requests(raw: str, unquote_value=True) -> Dict[str, str]:
    """
    Convierte un header Cookie o Set-Cookie en un dict simple para requests. Esto implica unquote de los valores.

    Args:
        unquote_value (bool, optional): Decodificar los valores con unquote. Defaults to True.
    """
    # TODO: agregar set_cookie en el nombre
    cookies = {}
    # Dividir por coma solo cuando empieza una nueva cookie (key=...)
    parts = [p.strip() for p in raw.split(",")]
    for part in parts:
        segments = [s.strip() for s in part.split(";")]
        if "=" in segments[0]:
            name, value = segments[0].split("=", 1)
            cookies[name] = unquote(value) if unquote_value else value  # decodifica %xx
    return cookies


def cookies_to_selenium(raw: str, domain: str) -> List[SeleniumCookie]:
    """
    Convierte un header Cookie o Set-Cookie en el formato esperado por Selenium.
    """
    # TODO: agregar set_cookie en el nombre o un mejor indicador
    selenium_cookies = []
    parts = [p.strip() for p in raw.split(",")]
    for part in parts:
        segments = [s.strip() for s in part.split(";")]
        if "=" not in segments[0]:
            continue
        name, value = segments[0].split("=", 1)

        cookie_dict: dict = {
            "name": name,
            "value": unquote(value),
            "domain": domain,
        }

        for attr in segments[1:]:
            if "=" in attr:
                k, v = attr.split("=", 1)
                if k.lower() == "path":
                    cookie_dict["path"] = v
            else:
                # Flags sin valor: secure, httponly, etc.
                if attr.lower() == "secure":
                    cookie_dict["secure"] = "True"

                if attr.lower() == "httponly":
                    cookie_dict["httpOnly"] = True

        selenium_cookies.append(SeleniumCookie(**cookie_dict))
    return selenium_cookies


def load_vocareum_params(filepath: Union[str, Path]) -> VocareumParams:
    filepath = Path(filepath) if isinstance(filepath, str) else filepath
    data = json.loads(filepath.read_text())
    vocareum_params = VocareumParams(**data)
    return vocareum_params


def load_netscape_cookies(filepath: Union[str, Path]) -> List[SeleniumCookie]:
    filepath = Path(filepath) if isinstance(filepath, str) else filepath
    cookies = []
    with open(filepath, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue  # ignorar comentarios y líneas vacías

            domain, flag, path, secure, expiration, name, value = line.split("\t")

            cookie = {
                "domain": domain,
                "path": path,
                "secure": secure.lower() == "true",
                "name": name,
                "value": value,
            }

            if expiration != "0":
                cookie["expiry"] = int(expiration)

            cookies.append(SeleniumCookie(**cookie))
    return cookies


def save_netscape_cookies(
    cookies: List[SeleniumCookie], filepath: Union[str, Path]
) -> None:
    filepath = Path(filepath) if isinstance(filepath, str) else filepath

    lines = [
        "# Netscape HTTP Cookie File",
        "# This file was generated by save_netscape_cookies()",
        "# Domain\tFlag\tPath\tSecure\tExpiration\tName\tValue",
    ]

    for cookie in cookies:
        domain = cookie.domain
        path = cookie.path
        secure = "TRUE" if cookie.secure else "FALSE"
        expiry = str(cookie.expiry)
        name = cookie.name
        value = cookie.value

        # flag = TRUE si el dominio empieza con ".", de lo contrario FALSE
        flag = "TRUE" if domain.startswith(".") else "FALSE"

        line = "\t".join([domain, flag, path, secure, expiry, name, value])
        lines.append(line)

    filepath.write_text("\n".join(lines), encoding="utf-8")


def parse_lab_aws_details_content(
    content: str,
) -> AWSDetailsStopped | AWSDetailsRunning:
    data = {}
    content_lab = clear_content(content)
    if len(content_lab) == 3:
        # el laboratorio no ha iniciado.
        session_started_at = content_lab[0]
        session_status_time = content_lab[1]
        accumulated_lab_time = content_lab[2]

        # --- parse session_started_at ---
        session_time_value = session_started_at.split(":", 1)[-1].strip()
        if session_time_value.startswith("-"):
            data["session_started_at"] = None
        else:
            data["session_started_at"] = datetime.strptime(
                session_time_value, "%Y-%m-%dT%H:%M:%S%z"
            )

        # --- parse session_status_time ---
        status = session_status_time.split()[1].strip()
        status_time = session_status_time.split()[-1].strip()

        data["session_status"] = status
        data["session_status_time"] = datetime.strptime(
            status_time, "%Y-%m-%dT%H:%M:%S%z"
        )

        # --- parse accumulated_lab_time ---

        data["accumulated_lab_time"] = parse_accumulated_time(accumulated_lab_time)
        return AWSDetailsStopped(**data)
    elif len(content_lab) == 6:
        # 'Copy and paste the following into ~/.aws/credentials[default]\naws_access_key_id=...'
        copy_and_paste_credentials = content_lab[0]
        # 'Remaining session time: 03:48:59(229 minutes)'
        remaining_session_time = content_lab[1]
        # 'Session started at: 2025-10-28T10:13:38-0700'
        session_started_at = content_lab[2]
        # 'Session to end\xa0 at: 2025-10-28T15:44:35-0700'
        session_to_end = content_lab[3]
        # 'Accumulated lab time: 1 day 08:22:00 (1942 minutes)'
        accumulated_lab_time = content_lab[4]
        #  'AWS SSO\xa0\xa0+QN9LsuSktElOcsrEg5dgg=='
        aws_sso = content_lab[5]

        # --- parse copy_and_paste_credentials ---
        data["copy_and_paste_credentials"] = copy_and_paste_credentials.split(
            "/credentials"
        )[1]
        # --- parse remaining_session_time ---
        data["remaining_session_time"] = parse_accumulated_time(
            remaining_session_time.split(":", 1)[-1].strip()
        )
        # --- parse session_started_at ---
        session_time_value = session_started_at.split(":", 1)[-1].strip()
        if session_time_value.startswith("-"):
            data["session_started_at"] = None
        else:
            data["session_started_at"] = datetime.strptime(
                session_time_value, "%Y-%m-%dT%H:%M:%S%z"
            )
        # --- parse session_to_end ---
        session_end_time_value = session_to_end.split(":", 1)[-1].strip()
        if session_end_time_value.startswith("-"):
            data["session_to_end"] = None
        else:
            data["session_to_end"] = datetime.strptime(
                session_end_time_value, "%Y-%m-%dT%H:%M:%S%z"
            )
        # --- parse accumulated_lab_time ---
        data["accumulated_lab_time"] = parse_accumulated_time(accumulated_lab_time)

        # --- parse aws_sso ---
        data["aws_sso"] = aws_sso.split()[-1].strip()

        return AWSDetailsRunning(**data)
    raise ValueError
